<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<!-- Viewport Meta Tag for Mobile Site -->
	<!-- https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag) -->
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>The Hask Category / Benjamin R. Bray</title>
	<link rel="stylesheet" href="../../css/style.css" />
	<link rel="stylesheet" href="../../css/article.css" />
	<link rel="stylesheet" href="../../css/pandoc-syntax.css" />
	<link rel="stylesheet" href="../../katex/katex.min.css" />
</head>

<!---- BODY ----------------------------------------------->
<body>
	<header id="header-box">
		<nav id="header">
			<ul id="header-nav">
				<li><a id="header-name" href="../../">Benjamin R. Bray</a></li>
				<li><a href="../../blog">WRITING</a></li>
				<li><a href="../../projects">PROJECTS</a></li>
				<li><a href="../../resources">RESOURCES</a></li>
				<li><a href="../../resume">RESUME</a></li>
			</ul>
		</nav>
	</header>
	
	<div id="pre-content">
    <!-- Banner -->
    
</div>

<div id="page">
<article id="content">
    <!-- Post Header -->
    <header class="article-header">
        <h1 class="article-title">The Hask Category</h1>
        <div class="article-info">
            <!-- Date -->
            <div class="article-date">
                Posted  on June  1, 2021
            </div>
            <!-- Tags / Tools -->
            <nav class="article-tags">
                <a href="../../tags/math" class="tag">math</a> <a href="../../tags/category-theory" class="tag">category-theory</a> <a href="../../tags/functional-programming" class="tag">functional-programming</a>
                <a href="../../tools/haskell" class="tool">haskell</a>
            </nav>
        </div>
        <div class="article-buttons">
            <!-- Demo URL -->
            
            <!-- GitHub URL -->
            
            <!-- PDF URL -->
            
        </div>
    </header>

    <!-- Body -->
    <section>
        <div class="toc"><h2>Table of Contents</h2>
<ul>
<li><a href="#the-category-hask">The Category <code>Hask</code></a>
<ul>
<li><a href="#hask-is-not-a-category">(<code>Hask</code> is Not a Category)</a></li>
<li><a href="#towards-a-solution">(Towards a Solution)</a></li>
<li><a href="#truth-from-lies">(Truth from Lies)</a></li>
<li><a href="#hask-is-not-cartesian-closed">(Hask is Not Cartesian Closed)</a></li>
</ul></li>
<li><a href="#endofunctors-in-hask">Endofunctors in <code>Hask</code></a>
<ul>
<li><a href="#endofunctors-categorically">Endofunctors, Categorically</a></li>
<li><a href="#expressing-functors-in-haskell">Expressing Functors in Haskell</a></li>
<li><a href="#the-functor-typeclass">The <code>Functor</code> Typeclass</a></li>
<li><a href="#aside-endofunctors-enriched-in-hask">Aside: Endofunctors Enriched in <code>Hask</code></a></li>
<li><a href="#aside-desugaring-functor">Aside: Desugaring <code>Functor</code></a></li>
</ul></li>
<li><a href="#natural-transformations-in-hask">Natural Transformations in <code>Hask</code></a>
<ul>
<li><a href="#examples-of-natural-transformations-in-hask">Examples of Natural Transformations in <code>Hask</code></a></li>
<li><a href="#yoneda-lemma-in-hask">Yoneda Lemma in <code>Hask</code></a></li>
</ul></li>
<li><a href="#monads-in-hask">Monads in <code>Hask</code></a></li>
<li><a href="#kleisli-category">Kleisli Category</a></li>
<li><a href="#exponentials-in-hask">Exponentials in <code>Hask</code></a>
<ul>
<li><a href="#misc">Misc</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<h2 id="the-category-hask">The Category <code>Hask</code></h2>
<blockquote>
<p>(note: this page is not original research, but rather a synthesis of the best explanations I could find online for each of these topics individually)</p>
<p>The Haskell Wikibook is written from the perspective of someone who knows a bit of Haskell and wants to know how it connects to category theory. Instead, I'm someone who knows a bit of category theory and wants to know how it connects to Haskell.</p>
</blockquote>
<p>Functional programming concepts like <code>Functor</code> and <code>Monad</code> do not always correspond in an obvious way to their category theory counterparts. These notes aim to clarify the relationship between Haskell syntax and category theory.</p>
<p>Haskellers like to imagine that there is a category <code>Hask</code> such that:</p>
<ul>
<li><p>objects in <code>Hask</code> are concrete data <strong>types</strong> of kind <code>*</code>.</p></li>
<li><p>morphisms in <code>Hask</code> are Haskell functions (which are <strong>values</strong>). For two concrete types <code>A</code> and <code>B</code>, the hom-set <code>Hom(A,B)</code> is the set of functions with signature <code>A -&gt; B</code>.</p></li>
<li><p>function composition is given by <code>f . g</code></p></li>
<li><p>the [[polymorphic]] function <code>id</code> provides an identity morphism <code>id :: A -&gt; A</code> for every data type <code>A</code></p></li>
</ul>
<p>The rest of this section explains why <code>Hask</code> is not actually a category.</p>
<h3 id="hask-is-not-a-category">(<code>Hask</code> is Not a Category)</h3>
<p>We follow the <a href="https://stackoverflow.com/a/48490015/1444650">explanation</a> by user K. A. Buhr on StackOverflow. According to <a href="https://wiki.haskell.org/Hask">HaskellWiki/Hask</a>, the magically-strict <a href="https://wiki.haskell.org/Seq"><code>seq</code></a><a href="https://wiki.haskell.org/Seq">function</a>allows us to construct morphisms which violate the category laws.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>undef1 <span class="ot">= undefined ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>undef2 <span class="ot">=</span> \_ <span class="ot">-&gt;</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Consider their monomorphic specializations to the type <code>() -&gt; ()</code>,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>undef1,<span class="ot"> undef2 ::</span> () <span class="ot">-&gt;</span> ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>undef1 <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>undef2 <span class="ot">=</span> \_ <span class="ot">-&gt;</span> <span class="fu">undefined</span></span></code></pre></div>
<p>It turns out that <code>undef1 . id = undef2</code>, so if the morphisms <code>Hask</code> are to be Haskell functions, the category laws mandate that <code>undef1</code> and <code>undef2</code> should refer to the same Haskell function. How can we check?</p>
<p>In Haskell, primitives like <code>Integer</code> can be directly compared. For compound types, we normally think of two values as being different if we can construct an expression that <strong><em>witnesses</em></strong> a difference in directly comparable values:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 4 is a witness to the fact that sqrt =/= id, allowing</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- us to conclude `sqrt` and `id` are different values</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span> <span class="dv">4</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span>   <span class="dv">4</span> <span class="ot">=</span> <span class="dv">4</span></span></code></pre></div>
<p>Similarly, <code>seq</code> witnesses the difference between <code>undef1</code> and <code>undef2</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">seq</span> undef1 ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- use defn of undef1</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="fu">seq</span> <span class="fu">undefined</span> ()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- seq semantics:  WHNF of undefined is _|_, so value is _|_</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> _<span class="op">|</span>_</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="fu">seq</span> undef2 ()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- use defn of undef2</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="fu">seq</span> (\_ <span class="ot">-&gt;</span> <span class="fu">undefined</span>) ()</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- seq semantics: (\_ -&gt; undefined) is already in WHNF</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- and is not _|_, so value is second arg ()</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> ()</span></code></pre></div>
<p>Since <code>undef1 . id = undef2</code>, but <code>undef1 ≠ undef2</code>, our category law is violated.</p>
<h3 id="towards-a-solution">(Towards a Solution)</h3>
<p>So, the wiki proposes instead that morphisms in <code>Hask</code> should be equivalence classes of Haskell functions, where <code>f</code> and <code>g</code> equivalent iff <code>f x = g x</code> for all inputs <code>x</code>.</p>
<p>However, <a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">Andrej Bauer points out</a> that due to the lack of a formal [[operational-semantics]] for Haskell, there is no rigorous way to determine if two expressions (therefore two morphisms) are equal. This idea is <a href="https://stackoverflow.com/a/48490015/1444650">explained further</a> by user K. A. Buhr on StackOverflow.</p>
<p>The <a href="https://en.wikibooks.org/wiki/Haskell/Category_theory#cite_note-1">Haskell Wikibook</a> proposes a different solution, which involves redefining function composition to be strict:</p>
<blockquote>
<p>We can define a new strict composition function, <code>f .! g = ((.) $! f) $! g</code>, that makes <strong>Hask</strong> a category. We proceed by using the normal <code>(.)</code>, though, and attribute any discrepancies to the fact that <code>seq</code> breaks an awful lot of the nice language properties anyway.</p>
</blockquote>
<p>A <a href="https://www.reddit.com/r/haskell/comments/4wk0gs/hask_is_not_a_category/d69j1de/">reddit comment</a> in response to Andrej Bauer's post proposes this:</p>
<blockquote>
<p><strong>Hask</strong> is this category:</p>
<ul>
<li><p>The objects are types of kind <code>*</code>.</p></li>
<li><p>For objects <code>A</code>, <code>B</code>, the hom-set <code>hom(A,B)</code> is the quotient <code>(A -&gt; B) / equal3{A,B}</code>, where <code>A -&gt; B</code> is the set of values of that type.</p></li>
<li><p>For object <code>A</code>, the identity morphism is the <code>equal3{A,A}</code> equivalence class containing <code>(\a -&gt; a) :: A -&gt; A</code>.</p></li>
<li><p>For objects <code>A</code>, <code>B</code>, <code>C</code>, and morphisms <code>F ∈ hom(A,B)</code>, <code>G ∈ hom(B,C)</code>, the composition <code>G . F</code> is the <code>equal3{A,C}</code> equivalence class containing <code>\a -&gt; g (f a)</code>, where <code>f ∈ F</code>, <code>g ∈ G</code>.</p></li>
</ul>
</blockquote>
<h3 id="truth-from-lies">(Truth from Lies)</h3>
<p>For the above reasons, among others, we cannot confidently say that <code>Hask</code> is a genuine category. Nevertheless, many constructs in Haskell are inspired by category theory, and treating <code>Hask</code> like a genuine category can lend some clarity to their definitions.</p>
<p>Moreover, <strong>fast and loose reasoning is morally correct</strong>:</p>
<ul>
<li>@[danielsson2006_fast-loose-morally-correct]</li>
</ul>
<h3 id="hask-is-not-cartesian-closed">(Hask is Not Cartesian Closed)</h3>
<p>Putting aside that <code>Hask</code> isn't even a category, the wiki points out a number of technical limitations prevent <code>Hask</code> from being a [[cartesian-closed-category]] as well.</p>
<ul>
<li><p>it does not have sums, products, or an initial object</p></li>
<li><p><code>()</code> is not a terminal object</p></li>
<li><p>the monad identities fail for almost all instances of <code>Monad</code></p></li>
</ul>
<p>Because of these difficulties, Haskell developers tend to think in some subset of Haskell (<code>PlatonicHask</code>) where types do not have [[bottom]] values.</p>
<ul>
<li><p><code>PlatonicHask</code> only includes functions that terminate, and typically only finite values</p></li>
<li><p>the corresponding category has the expected initial and terminal objects, sums and products, and instances of <code>Functor</code> and <code>Monad</code> really are endofunctors and monads</p></li>
</ul>
<h2 id="endofunctors-in-hask">Endofunctors in <code>Hask</code></h2>
<p>A [[functor]] is a map between categories that preserves categorical structure. In Haskell, we care most about [[endofunctors]], from the category <code>Hask</code> to itself.</p>
<h3 id="endofunctors-categorically">Endofunctors, Categorically</h3>
<p>An endofunctor <code>F : Hask -&gt; Hask</code> in the category <code>Hask</code> assigns</p>
<ul>
<li><p>to each type <code>A</code> in <code>Hask</code> a type <code>F A</code> in <code>Hask</code>.</p></li>
<li><p>to each Haskell function <code>f : A -&gt; B</code> a function <code>F f : F A -&gt; F B</code></p></li>
<li><p>such that <code>F (id :: A) = (id :: F A)</code></p></li>
<li><p>such that <code>F ( g . f ) = (Fg) . (Ff)</code> for <code>f : x -&gt; y</code>, <code>g : y -&gt; z</code></p></li>
</ul>
<h3 id="expressing-functors-in-haskell">Expressing Functors in Haskell</h3>
<blockquote>
<p>paraphrased from <a href="https://stackoverflow.com/a/67192985/1444650">leftaroundabout on StackOverflow</a></p>
</blockquote>
<p>Mathematically speaking, a functor is a [[dependent]] pair, where</p>
<ul>
<li><p>the object map <code>Type -&gt; Type</code> lives in Haskell's type-level world</p></li>
<li><p>the morphism map <code>(a -&gt; b) -&gt; f a -&gt; f b</code> lives in the value world</p></li>
</ul>
<p>Haskell doesn't have a way of specifying such dependent pairs. The <code>Functor</code> typeclass tricks its way around this limitation by allowing the use of <em>type constructors</em> as the <code>Type -&gt; Type</code> object mapping.</p>
<ul>
<li><p>This helps, because type constructors are unique. Every one of them can be assigned a well-defined morphism-mapping through Haskell's typeclass mechanism.</p></li>
<li><p>However, the image of a <code>Functor</code> is always the proper (full?) subcategory of types in the image of the type constructor, which prevents us from specifying arbitrary object mappings, as we might with a <code>type</code> synonym.</p></li>
</ul>
<p>IThe takeaway is that there are some (endo)functors in <code>Hask</code> which cannot be captured by a <code>Functor</code> instance.</p>
<p><strong>Example.</strong> (Identity Functor) For example, the <a href="https://hackage.haskell.org/package/transformers-0.2.1.0/docs/src/Data-Functor-Identity.html#Identity">identity</a><a href="https://hackage.haskell.org/package/transformers-0.2.1.0/docs/src/Data-Functor-Identity.html#Identity"><code>Functor</code></a> cannot map a type directly to itself. Instead, it sends each type to a wrapped, isomorphic copy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> {<span class="ot"> unwrap ::</span> a }</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Identity</span> x) <span class="ot">=</span> <span class="dt">Identity</span> (f x)</span></code></pre></div>
<p>So, <code>Identity</code> isn't, strictly speaking, the identity functor. Instead, the accessor <code>unwrap :: Identity a -&gt; a</code> is a natural isomorphism from <code>Identity</code> to the true, category-theoretic identity functor, which is expressible in Haskell as a type alias:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Id</span> a <span class="ot">=</span> a</span></code></pre></div>
<p>Type aliases in Haskell can't be [[typeclass]] instances, so we have to work with the naturally isomorphic <code>Identity</code> functor instead.</p>
<p><strong>Remark.</strong> Haskell does have a <code>TypeSynonymInstances</code> extension, which might not work as expected without also enabling <code>FlexibleInstances</code> and <code>OverlappingInstances</code>. See an <a href="https://stackoverflow.com/a/42892551/1444650">answer by mb14 on StackOverflow</a>.</p>
<p><strong>Example.</strong> (Const Functor) Similarly, a [[const-functor]] is naturally isomorphic to the constant functor we normally think of in category theory.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CF</span> m a <span class="ot">=</span> m</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- we have a constant functor</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">--     with object mapping     CF m</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">--     with morphism mapping   id @m  (type application syntax)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- but no way to pair them together!</span></span></code></pre></div>
<p>Due to Haskell's limitations, though, we end up in a situation where <code>Const Int Char</code> and <code>Const Int Bool</code> are technically speaking different, albeit isomorphic, types.</p>
<h3 id="the-functor-typeclass">The <code>Functor</code> Typeclass</h3>
<p>Every <code>Functor</code> in Haskell is an endofunctors from <code>Hask</code> to <code>Hask</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> (<span class="dt">F</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">F</span> b</span></code></pre></div>
<p>If you're wondering why we specify an <code>fmap</code> for morphisms but apparently no corresponding omap for objects, you're not alone!</p>
<ul>
<li><p>SO, <a href="https://stackoverflow.com/questions/21647659/why-functor-class-has-no-return-function">"Why Functor class has no return function?"</a></p></li>
<li><p>SO, <a href="https://stackoverflow.com/questions/33441140/why-is-pure-only-required-for-applicative-and-not-already-for-functor?noredirect=1&amp;lq=1">"Why is pure required for Applicative and not for Functor?"</a></p></li>
<li><p>SO, <a href="https://stackoverflow.com/questions/52219614/why-does-the-functor-class-in-haskell-not-include-a-function-on-objects-is-pur?noredirect=1&amp;lq=1">"Why does the Functor class in Haskell not include a function on objects? Is pure that function?"</a></p></li>
<li><p>SO, <a href="https://stackoverflow.com/questions/14820139/how-are-functors-in-haskell-related-to-functors-in-category-theory">"How are functors in Haskell related to functors in category theory?"</a></p></li>
</ul>
<p>Here are two example instances of <code>Functor</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> [] <span class="ot">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> (f x) <span class="op">:</span> (<span class="fu">fmap</span> xs)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Maybe sends type T to (Maybe T) </span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Notice that the type constructor <code>Maybe</code> sends each type <code>T</code> to a new type <code>Maybe T</code>. <strong>Hence the object map for the </strong>******************<code>Maybe</code>******************** functor is the type constructor itself!**</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- this isn't a real signature</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">T</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">T</span></span></code></pre></div>
<h3 id="aside-endofunctors-enriched-in-hask">Aside: Endofunctors Enriched in <code>Hask</code></h3>
<p>From <a href="https://stackoverflow.com/a/14851700/1444650">an answer by Eduardo Pareja Tobes</a> on StackOverflow:</p>
<blockquote>
<p>One important point about this is that what you really want is functors [[enriched]] in <strong>Hask</strong>, not just plain old functors. <strong>Hask</strong> is cartesian closed (<a href="http://blog.sigfpe.com/2009/10/what-category-do-haskell-types-and.html?showComment=1255861175804#c3365363734200015962"><u></a><a href="http://blog.sigfpe.com/2009/10/what-category-do-haskell-types-and.html?showComment=1255861175804#c3365363734200015962">not really</a><a href="http://blog.sigfpe.com/2009/10/what-category-do-haskell-types-and.html?showComment=1255861175804#c3365363734200015962"></u></a>, but it tries hard to be onesuch), and so it is naturally enriched in itself.</p>
<p>Now, [[enriched-endofunctors]] give you a way of restricting to those <strong><em>implementable within the language</em></strong>:</p>
<p>an enriched functor <strong>Hask -&gt; Hask</strong> is a function at the level of objects (types) <code>f a</code> and for each pair of objects <code>a, b</code> a morphism in <strong>Hask</strong> going <em>f : </em>***********Hask************(a,b) -&gt; ************Hask************(fa,fb)*. Of course, this is just <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p>
</blockquote>
<h3 id="aside-desugaring-functor">Aside: Desugaring <code>Functor</code></h3>
<p>We can desugar the typeclass syntax according to the rules described in @[peyton-jones2011_classes-not-as-we-know-them], giving</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- to make a functor instance, we just need an fmap</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Functor</span> f</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">MkFunctor</span> ((a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- given a Functor, selects the correct fmap function</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (<span class="dt">MkFunctor</span> m) <span class="ot">=</span> m</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- an instance declaration</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ot">dFunctorList ::</span> <span class="dt">Functor</span> []</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>dFunctorList <span class="ot">=</span> <span class="dt">MkFunctor</span> <span class="fu">map</span> <span class="kw">where</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">map</span> [] <span class="ot">=</span> []</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> (f x) <span class="op">:</span> (<span class="fu">fmap</span> xs)</span></code></pre></div>
<h2 id="natural-transformations-in-hask">Natural Transformations in <code>Hask</code></h2>
<blockquote>
<p>Following Milewski, "<a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/">CTfP, Natural Transformations</a>"</p>
<p>@[fong2020_cats4progs] Chapter 3</p>
<p>Milewski, <a href="https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/">"Parametricity: Money for Nothing and Theorems for Free"</a></p>
</blockquote>
<p>Given functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>, a natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi>F</mi><mo>⇒</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\alpha : F \Rightarrow G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> assigns</p>
<ul>
<li><p>to each datatype <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mtext mathvariant="monospace">Hask</mtext></mrow><annotation encoding="application/x-tex">x \in \Hask</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">Hask</span></span></span></span></span> a Haskell funcion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>x</mi></msub><mo>:</mo><mi>F</mi><mi>x</mi><mo>→</mo><mi>G</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha_x : Fx \rightarrow Gx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span></span></span></span></p></li>
<li><p>such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>y</mi></msub><mo>∘</mo><mi>F</mi><mi>f</mi><mo>=</mo><mi>G</mi><mi>f</mi><mo>∘</mo><msub><mi>α</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_y \circ Ff = Gf \circ \alpha_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.730558em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for all functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f : x \rightarrow y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></p></li>
</ul>
<p>In Haskell, a [[natural transformation]] between functors <code>f</code> and <code>g</code> is just a [[polymorphic]] function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Nat</span> f g <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>Every polymorphic function already gives a map between datatypes. As a consequence of [[parametric polymorphism]], a Haskell function of the type below automatically obeys the natural transformation law!</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- a family of functions parameterized by `a`</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre></div>
<p>To see why, recall that the action of a Haskell <code>Functor</code> <code>F</code> on a function <code>f</code> is implemented with <code>fmap :: (a -&gt; b) -&gt; (F a -&gt; F b)</code>. So, the natural transformation law above can be rewritten as</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- given functors F, G from Hask =&gt; Hask</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- for any f :: x -&gt; y, we require that</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">.</span> (<span class="fu">fmap</span> f) <span class="ot">=</span> (<span class="fu">fmap</span> f) <span class="op">.</span> alpha</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- (both sides of the equation have type Fx -&gt; Gy)</span></span></code></pre></div>
<p>Where parametric polymorphism allows us to omit subscripts.</p>
<blockquote>
<p>[[TODO]]: Finish this explanation of why parametrically polymorphic functions are automatically natural transformations. See @[reynolds1972-definitional-interpreters-higher-order-pl], @[wadler1989-theorems-for-free], and a <a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/">post by Milewski</a>.</p>
<p><strong>Q:</strong> is parametric polymorphism related to a universal property? see e.g. @[ghani2015_parametric-polymorphism-universally]</p>
</blockquote>
<h3 id="examples-of-natural-transformations-in-hask">Examples of Natural Transformations in <code>Hask</code></h3>
<p><strong>Example.</strong> The parametrically polymorphic function <code>safeHead</code> is a natural transformation from the <code>List</code> functor to the <code>Maybe</code> functor.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>safeHead []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>safeHead (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- naturality condition</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> safeHead <span class="ot">=</span> safeHead <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p><strong>Example.</strong> A natural transformation from or to a [[const-functor]] looks just like a function that's either polymorphic in its return type or in its argument type.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Const</span> a b <span class="ot">=</span> <span class="dt">Const</span> a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> m) <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> a <span class="ot">-&gt;</span> <span class="dt">Const</span> b</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ (<span class="dt">Const</span> a) <span class="ot">=</span> <span class="dt">Const</span> (f b)</span></code></pre></div>
<h3 id="yoneda-lemma-in-hask">Yoneda Lemma in <code>Hask</code></h3>
<blockquote>
<p>see [[yoneda-lemma]] for examples of Yoneda and coYoneda in <code>Hask</code></p>
</blockquote>
<h2 id="monads-in-hask">Monads in <code>Hask</code></h2>
<p>Following the <a href="https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads">Haskell Wikibook</a>, a [[monad]] in the category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> is an endofunctor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">M : C \rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> together with two natural transformations</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.2500em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mrow><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi></mrow><mi>M</mi></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><msub><mn>1</mn><mi>C</mi></msub><mo>→</mo><mi>M</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mi>M</mi></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mi>M</mi><mo>∘</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mathrm{unit}^M &amp;: 1_C       \rightarrow M \\
\mathrm{join}^M &amp;: M \circ M \rightarrow M
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.118182em;vertical-align:-1.309091em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.809091em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">unit</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899091em;"><span style="top:-3.12076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span></span><span style="top:-2.350909em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">join</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899091em;"><span style="top:-3.12076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.309091em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.809091em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span><span style="top:-2.350909em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.309091em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>This translates to the following Haskell typeclass:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p><code>Hask</code> is an endofunctor together with two morphisms for each</p>
<p>see [[monoid-in-the-category-of-endofunctors]]</p>
<h2 id="kleisli-category">Kleisli Category</h2>
<h2 id="exponentials-in-hask">Exponentials in <code>Hask</code></h2>
<p>An [[exponential]] is a universal function object.</p>
<ul>
<li>see Milewski, <a href="https://bartoszmilewski.com/2015/03/13/function-types/">"CTfP: Function Types"</a></li>
</ul>
<h3 id="misc">Misc</h3>
<p>coends?</p>
<h2 id="references">References</h2>
<p>Category <code>Hask</code></p>
<ul>
<li><p><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category">Haskell/CategoryTheory</a></p></li>
<li><p>Haskell Wiki, <a href="https://wiki.haskell.org/Hask">"Hask"</a></p></li>
<li><p>Andrej Bauer 2016, <a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">"Hask is not a Category"</a></p></li>
<li><p>StackOverflow, <a href="https://stackoverflow.com/questions/48485660/is-hask-even-a-category">Is Hask Even a Category?</a></p></li>
<li><p>Makoto Hamana 2007, <a href="http://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf">"What is the Category for Haskell?"</a></p></li>
<li><p>Fong, <a href="http://brendanfong.com/programmingcats_files/C4P-chapter1.pdf">"C4P: Is Haskell a Category?"</a></p></li>
<li><p>StackOverflow, <a href="https://stackoverflow.com/questions/37367390/do-all-type-classes-in-haskell-have-a-category-theoretic-analogue">"Do all Type Classes in Haskell Have a Category-Theoretic Analogue?"</a></p></li>
<li><p>StackOverflow, <a href="https://stackoverflow.com/questions/17380379/where-do-values-fit-in-category-of-hask">"Where to values fit in Category of Hask?"</a></p>
<ul>
<li>talks about a different category where values are objects and functions are either morphisms or functors</li>
</ul></li>
<li><p>[my question] StackOverflow, <a href="https://stackoverflow.com/questions/67189886/is-haskells-const-functor-analogous-to-the-constant-functor-from-category-the">"Is Haskell's</a><a href="https://stackoverflow.com/questions/67189886/is-haskells-const-functor-analogous-to-the-constant-functor-from-category-the"><code>Const</code></a><a href="https://stackoverflow.com/questions/67189886/is-haskells-const-functor-analogous-to-the-constant-functor-from-category-the">Functor analogous to the constant functor from category theory?"</a></p></li>
</ul>
<p>Functors</p>
<ul>
<li>StackOverflow, <a href="https://stackoverflow.com/questions/21647659/why-functor-class-has-no-return-function">"Why Functor class has no return function?"</a></li>
</ul>
<p>Natural Transformations</p>
<ul>
<li>StackOverflow, <a href="https://stackoverflow.com/questions/58363868/what-is-a-natural-transformation-in-haskell">"What is a natural transformation in Haskell?"</a></li>
</ul>
<p>Monads</p>
<ul>
<li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">"Monad (Category Theory)"</a></li>
</ul>

    </section>
</article>
</div>


	<footer id="page-footer">
		<span style="float: left; vertical-align: middle">
			<img id="visitor-count" src="https://hitcounter.pythonanywhere.com/count/tag.svg" alt="Hits">
			Powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a> and <a href="https://github.com/benrbray/benrbray.github.io">hosted on GitHub</a>.
		</span>
		<span style="float: right">
			Generated February 23, 2023
		</span>
	</footer>
<!--------------------------------------------------------->
</body>

</html>